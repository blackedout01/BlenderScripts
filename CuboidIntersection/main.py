import bpy
import gpu
import bgl
from gpu_extras.batch import batch_for_shader
from mathutils import Vector
from mathutils import Quaternion
from dataclasses import dataclass
from typing import List
import time

# Vector @ Vector = dot
# Quaternion @ Vector = rotate

# s = obj.scale
# q = obj.rotation_quaternion
# x = obj.location

def scale(a, b):
    x = a[0] * b[0]
    y = a[1] * b[1]
    z = a[2] * b[2]
    return Vector((x, y, z))

def dot(a, b):
    return a @ b

def cross(a, b):
    return a.cross(b)

def normalize(a):
    return a.normalized()

def abs(a):
    if a < 0.0:
        return -a
    return a

def signft(a):
    if a < 0.0:
        return -1.0;
    return 1.0

def conjugate(a):
    return a.conjugated()

ex = Vector((1.0, 0.0, 0.0))
ey = Vector((0.0, 1.0, 0.0))
ez = Vector((0.0, 0.0, 1.0))

def semiaxes_local(obj):
    h = [
        scale(obj.scale, Vector((1.0, 0.0, 0.0))),
        scale(obj.scale, Vector((0.0, 1.0, 0.0))),
        scale(obj.scale, Vector((0.0, 0.0, 1.0))),
    ]
    return h

def semiaxes_oriented(obj):
    hl = semiaxes_local(obj)
    h = [(obj.rotation_quaternion @ hl[i]) for i in range(3)]
    return h

@dataclass
class RigidCuboid:
    x: Vector
    s: Vector
    q: Quaternion
    h: List[Vector]

vp = []
vc = []
pvp = []
pvc = []

def addpoint(p, c = (1, 1, 1, 1)):
    global pvp, pvc
    pvp += [p[:]]
    pvc += [c]

def addline(p1, p2, c = (1, 1, 1, 1)):
    global vp, vc
    vp += [p1[:], p2[:]]
    vc += [c, c]
    
def addline2(p1, p2, c1 = (0, 0, 0, 1), c2 = (1, 1, 1, 1)):
    global vp, vc
    vp += [p1[:], p2[:]]
    vc += [c1, c2]
    
def addvector(a, v, c = (1, 1, 1, 1)):
    addline(a, a+v, c)
    
def addvector2(a, v, c1 = (0, 0, 0, 1), c2 = (1, 1, 1, 1)):
    addline2(a, a+v, c1, c2)

def boxBoxIntersection(c1, c2):
    
    a = [ex, ey, ez]

    a1 = c1.h
    a2 = c2.h

    c = c1.x - c2.x;

    minDist = -float("inf")
    minN = Vector()
    q1 = Vector()
    q2 = Vector()
    e1 = Vector()
    e2 = Vector()
    
    c1Out = []
    c2Out = []

    # c1 face directions
    for i in range(3):
        n = normalize(a1[i])
        dist = abs(dot(n, c))
        
        for k in range(3):
            dist -= abs(dot(n, a1[k]))
            dist -= abs(dot(n, a2[k]))

        if dist > 0.0:
            return False
        elif dist > minDist:
            minDist = dist
            minN = n
            plane = True
            c1_is_cN = True
            cN = c1
            aN = a1
            cP = c2
            aP = a2
            e1 = a1[(i+1)%3]
            e2 = a1[(i+2)%3]
            ni = i

    # c2 face directions
    for i in range(3):
        n = normalize(a2[i])
        dist = abs(dot(n, c))
        
        for k in range(3):
            dist -= abs(dot(n, a1[k]))
            dist -= abs(dot(n, a2[k]))

        if dist > 0.0:
            return False
        elif dist > minDist:
            minDist = dist
            minN = n
            plane = True
            c1_is_cN = False
            cN = c2
            aN = a2
            cP = c1
            aP = a1
            e1 = a2[(i+1)%3]
            e2 = a2[(i+2)%3]
            ni = i
    
    # Edge edge case
    for i in range(3):
        for j in range(3):
            n = cross(a1[i], a2[j])
            ndotn = dot(n, n)
            if ndotn == 0.0:
                continue
            n = normalize(n)
            dist = abs(dot(n, c))
            
            for k in range(3):
                dist -= abs(dot(n, a1[k]))
                dist -= abs(dot(n, a2[k]))

            if dist > 0.0:
                return False
            elif dist - minDist > 1e-5: # TODO: 1e-?
                minDist = dist
                minN = n
                plane = False
                e1 = a1[i]
                e2 = a2[j]
    
    def sign0(a):
        # NOTE: Account for floating point errors
        epsilon = 1e-6
        if a < -epsilon:
            return -1.0
        if a > epsilon:
            return 1.0
        return 0.0
    
    minDist = -minDist
    if plane:
        nf = signft(dot(cP.x - cN.x, minN))
        n = nf * minN
        
        addvector(cN.x, n)
        
        dots = [-sign0(dot(n, aP[i])) for i in range(3)]
        qP = scale(cP.s, Vector((dots[0], dots[1], dots[2])))
        
        # clipSpace contains all four corner points of
        # the maximal face in normal direction
        
        # clipPoints initially contains 1, 2 or 4 points
        # they are generated by starting with a single point that is
        # the minimum corner point of cP along the normal n
        # if the choice for any corner direction is ambiguous (dot 0.0)
        # then the mid direction is chosen
        # any ambiguous direction is split such that clipPoints contains
        # up to four points (two splits)
        # all clip points are moved into the clip space plane for correct
        # intersection computation by correcting the starting point
        # (+ minDist*n)
        
        qN = cN.x + nf*aN[ni]
        addpoint(qN)
        clipSpace = [
            qN + e1 + e2,
            qN + e1 - e2,
            qN - e1 - e2,
            qN - e1 + e2,
        ]
        for p in clipSpace:
            addpoint(p)
        clipPoints = [cP.x + (cP.q @ qP) + minDist*n]
        
        for i in range(3):
            if dots[i] == 0.0:
                l = len(clipPoints)
                for j in range(l):
                    clipPoints.append(clipPoints[j] - aP[i])
                for j in range(l):
                    clipPoints[j] += aP[i]
                    
        if len(clipPoints) > 1:
            for p in clipSpace:
                addpoint(p, (0, 0, 0, 1))
            for p in clipPoints:
                addpoint(p, (1, 0.6, 0, 1))
            
            # swap points such that the list can be correctly traversed
            # for finding edges
            if len(clipPoints) > 2:
                tmp = clipPoints[2] + Vector()
                clipPoints[2] = clipPoints[3]
                clipPoints[3] = tmp
            
            # clip clipPoints against clipSpace using the
            # Sutherland-Hodgman algorithm:
            # https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
            
            for i in range(len(clipSpace)):
                corner1 = clipSpace[i-1]
                corner2 = clipSpace[i]
                clipN = normalize((corner1 + corner2) / 2 - cN.x)
                clipN -= dot(n, clipN)*n
                
                cornerOut = []
                cornerPrev = clipPoints[-1] + Vector()
                for j in range(len(clipPoints)):
                    cornerCurr = clipPoints[j]
                    
                    # Compute intersection
                    # s = dot(clipN, aE - aG)/dot(clipN, rG))
                    rG = cornerPrev - cornerCurr
                    divf = dot(clipN, rG)
                    if divf == 0.0:
                        S = Vector()
                    else:
                        s = dot(clipN, corner2 - cornerCurr)/divf
                        S = cornerCurr + s*rG
                        
                    currInside = dot(clipN, cornerCurr - corner2) < 0.0
                    prevInside = dot(clipN, cornerPrev - corner2) < 0.0
                    if currInside:
                        if not prevInside:
                            cornerOut.append(S)
                        cornerOut.append(cornerCurr)
                    elif prevInside:
                        cornerOut.append(S)
                    
                    cornerPrev = cornerCurr
                clipPoints = cornerOut
        
        for p in clipPoints:
            addpoint(p, (0.6, 1, 0, 1))

        # clipped points lie in the clip space plane, so on cN
        if c1_is_cN:
            for i in range(len(clipPoints)):
                p1 = clipPoints[i]
                c1Out.append(p1)
                c2Out.append(p1 - minDist*n)
        else:
            for i in range(len(clipPoints)):
                p2 = clipPoints[i]
                c1Out.append(p2 - minDist*n)
                c2Out.append(p2)
        
    else:
        # make the normal point roughly from c1 to c2
        n = signft(dot(c2.x - c1.x, minN)) * minN
        
        addvector(c1.x, n)
        addvector(c2.x, n)
        
        # NOTE:
        # find position vectors b1, b2 of the two closest edges
        # if any dot is zero choose the edge point that is closest
        # to the other center point
        
        # TODO:
        # B unmodified cube
        # A scale 2, rotate 45Â° around Z, from above B
        # maybe check if normal is equal to any half axis?
        # or use epsilon to update minDist edge edge case?
        
        dots1 = [sign0(dot(n, a1[i])) for i in range(3)]
        dots2 = [-sign0(dot(n, a2[i])) for i in range(3)]
        
        '''
        for i in range(3):
            if dots1[i] == 0.0:
                dots1[i] = sign0(dot(c2.x - c1.x, a1[i]))
            if dots2[i] == 0.0:
                dots2[i] = sign0(dot(c1.x - c2.x, a2[i]))
        '''
        
        x1 = scale(Vector((dots1[0], dots1[1], dots1[2])), c1.s)
        b1 = c1.x + (c1.q @ x1)
        x2 = scale(Vector((dots2[0], dots2[1], dots2[2])), c2.s)
        b2 = c2.x + (c2.q @ x2)
        
        addpoint(b1, (0.0, 0.0, 0.5, 1.0))
        addpoint(b2, (0.0, 0.0, 0.5, 1.0))
        addvector(b1, e1, (0.0, 0.0, 0.5, 1.0))
        addvector(b2, e2, (0.0, 0.0, 0.5, 1.0))
        
        #addvector(c1.x, r.n, (0.0, 0.0, 0.0, 1.0))
        #addvector(c2.x, r.n, (0.0, 0.0, 0.0, 1.0))
        
        nE = cross(e1, n)
        dotp = dot(nE, e2)
        if dotp == 0.0:
            dotp = 1.0
            addpoint(c1.x, (1, 0, 0, 1))
        param2 = (dot(nE, b1 - b2)/dotp)
        q2 = b2 + param2*e2
        q1 = q2 + minDist*n
        
        c1Out.append(q1)
        c2Out.append(q2)

    for i in range(len(c1Out)):
        p1 = c1Out[i]
        p2 = c2Out[i]
        addpoint(p1)
        addpoint(p2)
        addline(c1.x, p1, (0.1, 0.6, 0.1, 1))
        addline(c2.x, p2, (0.1, 0.1, 0.6, 1))
        addline(p1, p2, (0.8, 0, 0, 1))
        
    return True


@dataclass
class Args:
    t: float
    inter: bool

argsin = Args(time.time(), False)

def draw(args):
    
    # TODO: ...
    ct = time.time()
    dt = ct - args.t
    if dt > 0.1:
        args.t = ct
        recompute = True
    else:
        recompute = False
    
    recompute = True
    
    vp.clear()
    vc.clear()
    pvp.clear()
    pvc.clear()
    
    objects = bpy.data.objects
    o1 = objects[0]
    o2 = objects[1]
    o1.rotation_mode = "QUATERNION"
    o2.rotation_mode = "QUATERNION"
    h1 = semiaxes_oriented(o1)
    h2 = semiaxes_oriented(o2)    
    c1 = RigidCuboid(o1.location, o1.scale, o1.rotation_quaternion, h1)
    c2 = RigidCuboid(o2.location, o2.scale, o2.rotation_quaternion, h2)
    r = boxBoxIntersection(c1, c2)
        
    shader = gpu.shader.from_builtin('3D_SMOOTH_COLOR')
    shader.bind()
    
    batch = batch_for_shader(shader, 'LINES', {"pos": vp, "color": vc})
    bgl.glLineWidth(3.0)
    batch.draw(shader)
    batch = batch_for_shader(shader, 'POINTS', {"pos": pvp, "color": pvc})
    bgl.glPointSize(8.0)
    batch.draw(shader)

new_handler = bpy.types.SpaceView3D.draw_handler_add(draw, (argsin,), 'WINDOW', 'POST_VIEW')

# https://blender.stackexchange.com/questions/75612/how-do-you-remove-a-draw-handler-after-its-been-added
dns = bpy.app.driver_namespace
if "the_draw_handler" in dns:
    old_handler = dns["the_draw_handler"]
    bpy.types.SpaceView3D.draw_handler_remove(old_handler, 'WINDOW')
    print("handler removed")
else:
    print("no handler removed")

dns["the_draw_handler"] = new_handler