import bpy
import gpu
import bgl
from gpu_extras.batch import batch_for_shader
from mathutils import Vector
from mathutils import Quaternion
from dataclasses import dataclass
from typing import List
import time

# Vector @ Vector = dot
# Quaternion @ Vector = rotate

# s = obj.scale
# q = obj.rotation_quaternion
# x = obj.location


'''
TODO:
    x A
    2.94522 m
    0.779086 m
    0.23089 m
    s A
    0.4
    0.1
    0.1
    q B
    0.996589
    0.08252
    0.0
    0.0
    10.0
    10.0
    0.1

'''

def scale(a, b):
    x = a[0] * b[0]
    y = a[1] * b[1]
    z = a[2] * b[2]
    return Vector((x, y, z))


def dot(a, b):
    return a @ b

def cross(a, b):
    return a.cross(b)

def normalize(a):
    return a.normalized()

def abs(a):
    if a < 0.0:
        return -a
    return a

def signft(a):
    if a < 0.0:
        return -1.0;
    return 1.0

def conjugate(a):
    return a.conjugated()

ex = Vector((1.0, 0.0, 0.0))
ey = Vector((0.0, 1.0, 0.0))
ez = Vector((0.0, 0.0, 1.0))

def semiaxes_local(obj):
    h = [
        scale(obj.scale, Vector((1.0, 0.0, 0.0))),
        scale(obj.scale, Vector((0.0, 1.0, 0.0))),
        scale(obj.scale, Vector((0.0, 0.0, 1.0))),
    ]
    return h

def semiaxes_oriented(obj):
    hl = semiaxes_local(obj)
    h = [(obj.rotation_quaternion @ hl[i]) for i in range(3)]
    return h

@dataclass
class RigidCuboid:
    x: Vector
    s: Vector
    q: Quaternion
    h: List[Vector]
    
@dataclass
class IntRes:
    inter: bool
    p1: Vector
    p2: Vector

vp = []
vc = []
pvp = []
pvc = []

def addpoint(p, c = (1, 1, 1, 1)):
    global pvp, pvc
    pvp += [p[:]]
    pvc += [c]

def addline(p1, p2, c = (1, 1, 1, 1)):
    global vp, vc
    vp += [p1[:], p2[:]]
    vc += [c, c]
    
def addline2(p1, p2, c1 = (0, 0, 0, 1), c2 = (1, 1, 1, 1)):
    global vp, vc
    vp += [p1[:], p2[:]]
    vc += [c1, c2]
    
def addvector(a, v, c = (1, 1, 1, 1)):
    addline(a, a+v, c)
    
def addvector2(a, v, c1 = (0, 0, 0, 1), c2 = (1, 1, 1, 1)):
    addline2(a, a+v, c1, c2)

def boxBoxIntersection(c1, c2):
    
    a = [ex, ey, ez]

    a1 = c1.h
    a2 = c2.h

    c = c1.x - c2.x;

    minDist = -float("inf")
    minN = Vector()
    q1 = Vector()
    q2 = Vector()
    e1 = Vector()
    e2 = Vector()

    # c1 face directions
    for i in range(3):
        n = normalize(a1[i])
        dist = abs(dot(n, c))
        
        for k in range(3):
            dist -= abs(dot(n, a1[k]))
            dist -= abs(dot(n, a2[k]))

        if dist > 0.0:
            return IntRes(False, q1, q2)
        elif dist > minDist:
            minDist = dist
            minN = n
            plane = True
            c1_is_cN = True
            cN = c1
            aN = a1
            cP = c2
            aP = a2

    # c2 face directions
    for i in range(3):
        n = normalize(a2[i])
        dist = abs(dot(n, c))
        
        for k in range(3):
            dist -= abs(dot(n, a1[k]))
            dist -= abs(dot(n, a2[k]))

        if dist > 0.0:
            return IntRes(False, q1, q2)
        elif dist > minDist:
            minDist = dist
            minN = n
            plane = True
            c1_is_cN = False
            cN = c2
            aN = a2
            cP = c1
            aP = a1
    
    # Edge edge case
    for i in range(3):
        for j in range(3):
            n = cross(a1[i], a2[j])
            ndotn = dot(n, n)
            if ndotn == 0.0:
                continue
            n = normalize(n)
            dist = abs(dot(n, c))
            
            for k in range(3):
                dist -= abs(dot(n, a1[k]))
                dist -= abs(dot(n, a2[k]))

            if dist > 0.0:
                return IntRes(False, q1, q2)
            elif dist - minDist > 0.0: # TODO: 1e-5
                minDist = dist
                minN = n
                plane = False
                e1 = a1[i]
                e2 = a2[j]
    
    def sign0(a):
        if a < 0.0:
            return -1.0
        if a > 0.0:
            return 1.0
        return 0.0
    
    minDist = -minDist
    if plane:
        n = signft(dot(cP.x - cN.x, minN)) * minN;
        
        addvector(cN.x, n)
        
        dots = [-sign0(dot(n, aP[i])) for i in range(3)]
        qP = scale(cP.s, Vector((dots[0], dots[1], dots[2])))
        
        # clipSpace is the set of points that the clipPoints are clipped against
        # clipSpace contains the 4 normal points
        # they are generated by starting in the mid point of the face and
        # then splitting along every axis that is perpendicular to the normal        
        
        # clipPoint contains 1, 2 or 4 points
        # they are generated similar to the clipSpace points, the
        # starting point is the minimum corner point of cP along the normal n
        # if two corner points are equally minimal their mid is chosen (dot 0.0)
        # these equally minimal points are then split
        
        clipSpace = [cN.x + scale(n, cN.s)] # cN
        clipPoints = [cP.x + cP.q @ qP] # cP
        
        for i in range(3):
            if dots[i] == 0.0:
                l = len(clipPoints)
                for j in range(l):
                    clipPoints.append(clipPoints[j] - aP[i])
                for j in range(l):
                    clipPoints[j] += aP[i]
            if dot(n, aN[i]) == 0.0:
                l = len(clipSpace)
                for j in range(l):
                    clipSpace.append(clipSpace[j] - aN[i])
                for j in range(l):
                    clipSpace[j] += aN[i]
                    
        if len(clipPoints) > 1:
            for p in clipSpace:
                addpoint(p, (0, 0, 0, 1))
            for p in clipPoints:
                addpoint(p, (1, 0.6, 0, 1))
            
            # move all clip points into the clip space plane for correct
            # intersection computation
            for i in range(len(clipPoints)):
                clipPoints[i] += minDist*n
            
            # swap points such that the list can be correctly traversed
            # for finding edges
            if len(clipSpace) > 2: # TODO: how/why does this happen?
                tmp = clipSpace[2] + Vector()
                clipSpace[2] = clipSpace[3]
                clipSpace[3] = tmp
            if len(clipPoints) > 2:
                tmp = clipPoints[2] + Vector()
                clipPoints[2] = clipPoints[3]
                clipPoints[3] = tmp
            
            # clip clipPoints against clipSpace using the
            # Sutherland-Hodgman algorithm:
            # https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
            
            for i in range(len(clipSpace)):
                corner1 = clipSpace[i-1]
                corner2 = clipSpace[i]
                clipN = normalize((corner1 + corner2) / 2 - cN.x)
                clipN -= dot(n, clipN)*n
                
                cornerOut = []
                cornerPrev = clipPoints[-1] + Vector()
                for j in range(len(clipPoints)):
                    cornerCurr = clipPoints[j]
                    
                    # Compute intersection
                    # s = dot(clipN, aE - aG)/dot(clipN, rG))
                    rG = cornerPrev - cornerCurr
                    divf = dot(clipN, rG)
                    if divf == 0.0:
                        S = Vector()
                    else:
                        s = dot(clipN, corner2 - cornerCurr)/divf
                        S = cornerCurr + s*rG
                        
                    currInside = dot(clipN, cornerCurr - corner2) < 0.0
                    prevInside = dot(clipN, cornerPrev - corner2) < 0.0
                    if currInside:
                        if not prevInside:
                            cornerOut.append(S)
                        cornerOut.append(cornerCurr)
                    elif prevInside:
                        cornerOut.append(S)
                    
                    cornerPrev = cornerCurr
                clipPoints = cornerOut
        
        for p in clipPoints:
            addpoint(p, (0.6, 1, 0, 1))
        
        # let qN equal the average of the clipped points
        # (lies in the clip space plane, so on cN)
        qN = Vector()
        l = len(clipPoints)
        for i in range(l):
            qN += clipPoints[i]
        qN = (1 / l) * qN # TODO: divide by zero error!?
        
        qP = conjugate(cP.q) @ (qN - minDist*n - cP.x)
        qN = conjugate(cN.q) @ (qN - cN.x)
        
        if c1_is_cN:
            q1 = qN
            q2 = qP
        else:
            q1 = qP
            q2 = qN
            
        p1 = c1.x + (c1.q@q1)
        p2 = c2.x + (c2.q@q2)
        
    else:
        # make the normal point roughly from c1 to c2
        n = signft(dot(c2.x - c1.x, minN)) * minN;
        
        # NOTE:
        # find position vectors b1, b2 of the two closest edges
        # if any dot is zero choose the edge point that is closest
        # to the other center point
        
        # TODO:
        # B unmodified cube
        # A scale 2, rotate 45Â° around Z, from above B
        # maybe check if normal is equal to any half axis?
        # or use epsilon to update minDist edge edge case?
        
        dots1 = [sign0(dot(n, a1[i])) for i in range(3)]
        dots2 = [-sign0(dot(n, a2[i])) for i in range(3)]
        
        for i in range(3):
            if dots1[i] == 0.0:
                dots1[i] = sign0(dot(c2.x - c1.x, a1[i]))
            if dots2[i] == 0.0:
                dots2[i] = sign0(dot(c1.x - c2.x, a2[i]))
        
        x1 = scale(Vector((dots1[0], dots1[1], dots1[2])), c1.s)
        b1 = c1.x + (c1.q @ x1)
        x2 = scale(Vector((dots2[0], dots2[1], dots2[2])), c2.s)
        b2 = c2.x + (c2.q @ x2)
        
        addpoint(b1, (0.0, 0.0, 0.5, 1.0))
        addpoint(b2, (0.0, 0.0, 0.5, 1.0))
        addvector(b1, e1, (0.0, 0.0, 0.5, 1.0))
        addvector(b2, e2, (0.0, 0.0, 0.5, 1.0))
        
        #addvector(c1.x, r.n, (0.0, 0.0, 0.0, 1.0))
        #addvector(c2.x, r.n, (0.0, 0.0, 0.0, 1.0))
        
        nE = cross(e1, n)
        dotp = dot(nE, e2)
        if dotp == 0.0:
            dotp = 1.0
        param2 = (dot(nE, b1 - b2)/dotp)
        p2 = b2 + param2*e2
        p1 = p2 + minDist*n

        q1 = conjugate(c1.q) @ (p1 - c1.x)
        q2 = conjugate(c2.q) @ (p2 - c2.x)

    addline(c1.x, p1, (0.1, 0.6, 0.1, 1))
    addline(c2.x, p2, (0.1, 0.1, 0.6, 1))
    addpoint(p1)
    addpoint(p2)
    addline(p1, p2, (0.8, 0, 0, 1))

    return IntRes(True, q1, q2)


@dataclass
class Args:
    t: float
    inter: bool

argsin = Args(time.time(), False)

def draw(args):
    
    # TODO: ...
    ct = time.time()
    dt = ct - args.t
    if dt > 0.1:
        args.t = ct
        recompute = True
    else:
        recompute = False
    
    recompute = True
    
    vp.clear()
    vc.clear()
    pvp.clear()
    pvc.clear()
    
    objects = bpy.data.objects
    o1 = objects[0]
    o2 = objects[1]
    o1.rotation_mode = "QUATERNION"
    o2.rotation_mode = "QUATERNION"
    h1 = semiaxes_oriented(o1)
    h2 = semiaxes_oriented(o2)    
    c1 = RigidCuboid(o1.location, o1.scale, o1.rotation_quaternion, h1)
    c2 = RigidCuboid(o2.location, o2.scale, o2.rotation_quaternion, h2)
    r = boxBoxIntersection(c1, c2)
        
    shader = gpu.shader.from_builtin('3D_SMOOTH_COLOR')
    shader.bind()
    
    batch = batch_for_shader(shader, 'LINES', {"pos": vp, "color": vc})
    bgl.glLineWidth(3.0)
    batch.draw(shader)
    batch = batch_for_shader(shader, 'POINTS', {"pos": pvp, "color": pvc})
    bgl.glPointSize(8.0)
    batch.draw(shader)

new_handler = bpy.types.SpaceView3D.draw_handler_add(draw, (argsin,), 'WINDOW', 'POST_VIEW')

# https://blender.stackexchange.com/questions/75612/how-do-you-remove-a-draw-handler-after-its-been-added
dns = bpy.app.driver_namespace
if "the_draw_handler" in dns:
    old_handler = dns["the_draw_handler"]
    bpy.types.SpaceView3D.draw_handler_remove(old_handler, 'WINDOW')
    print("handler removed")
else:
    print("no handler removed")

dns["the_draw_handler"] = new_handler